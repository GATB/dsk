//! [snippet1]
// We include what we need for the test
#include <gatb/gatb_core.hpp>
#include <DSK.hpp>
#include <fstream>

// We use the required packages
using namespace std;

/********************************************************************************/
class DSK2ASCII : public Tool
{
public:

    /** */
    DSK2ASCII () : Tool ("dsk2ascii")
    {
        getParser()->push_front (new OptionOneParam (STR_URI_OUTPUT, "output file",           true));
        getParser()->push_front (new OptionOneParam (STR_URI_FILE,   "file generated by dsk", true));
    }

    /** */
    void execute ()
    {
        // We get a handle on the HDF5 storage object.
        // Note that we use an auto pointer since the StorageFactory dynamically allocates an instance
        Storage* storage = StorageFactory(DSK::getStorageMode()).load (getInput()->getStr(STR_URI_FILE));
        LOCAL (storage);

        string kmerSizeStr = storage->getGroup("dsk").getProperty ("kmer_size");

        if (kmerSizeStr.empty())  { throw Exception ("unable to get the kmer size"); }

        size_t kmerSize = atoi (kmerSizeStr.c_str());

        /** We launch dsk with the correct Integer implementation according to the choosen kmer size. */
        Integer::apply<Functor,Parameter> (kmerSize, Parameter(*this, storage, kmerSize));
    }

    struct Parameter
    {
        Parameter (DSK2ASCII& tool, Storage* storage, size_t kmerSize) : tool(tool), storage(storage), kmerSize(kmerSize)  {}
        DSK2ASCII& tool;
        Storage*   storage;
        size_t     kmerSize;
    };

    template<size_t span> struct Functor  {  void operator ()  (Parameter parameter)
    {
        DSK2ASCII& tool     = parameter.tool;
        Storage*   storage  = parameter.storage;
        size_t     kmerSize = parameter.kmerSize;

        typedef typename Kmer<span>::Count Count;

        // We get the solid kmers collection 1) from the 'dsk' group  2) from the 'solid' collection
        Partition<Count>& solidKmers = storage->getGroup("dsk").getPartition<Count> ("solid");

        // We create a Model instance. It will help to dump the kmers in
        // a human readable form (ie as a string of nucleotides)
        typename Kmer<span>::ModelCanonical model (atol (storage->getGroup("dsk").getProperty ("kmer_size").c_str()));

        // We create the output file
        fstream output (tool.getInput()->getStr(STR_URI_OUTPUT).c_str(), std::fstream::out);

        // We iterate (through a lambda expression) the solid kmers from the retrieved collection
        Iterator<Count>* itKmers = tool.createIterator (solidKmers.iterator(), solidKmers.getNbItems(), "parsing");
        LOCAL(itKmers);

        for (itKmers->first(); !itKmers->isDone(); itKmers->next())
        {
            const Count& count = itKmers->item();
            output << model.toString(count.value) << " " << count.abundance << endl;
        }

        output.close();

        /** We gather some statistics. */
        tool.getInfo()->add (1, "stats");
        tool.getInfo()->add (2, "kmer_size", "%ld", kmerSize);
        tool.getInfo()->add (2, "nb_kmers",  "%ld", solidKmers.getNbItems());
    }};
};

/********************************************************************************/
/*                       Dump solid kmers in ASCII format                       */
/********************************************************************************/
int main (int argc, char* argv[])
{
    try
    {
        DSK2ASCII().run (argc, argv);
    }
    catch (Exception& e)
    {
        std::cout << "EXCEPTION: " << e.getMessage() << std::endl;
        return EXIT_FAILURE;
    }
}
//! [snippet1]
